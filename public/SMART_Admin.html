<!doctype html>
<html lang="ar" dir="rtl">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Admin</title>
  <link rel="stylesheet" type="text/css" href="SMART_Admin.css" />
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600&display=swap" rel="stylesheet" />

</head>

<body>
  <div id="pageOverlay">
    <div id="loadingSpinner"></div>
  </div>

  <div class="table-header">
    <h2>Smart Meters</h2>
    <div class="meta">
      <div>Ø§Ù„ØªØ§Ø±ÙŠØ®: <strong id="printDate">â€”</strong></div>
      <div>Admin</div>
    </div>
  </div>

  <div class="wrapper">
    <div class="sidebar">
      <h3>ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</h3>
      <button type="button" id="restorbtn">Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button>
      <label for="excelFile">Ø±ÙØ¹ Ù…Ù„Ù Ø§ÙƒØ³ÙŠÙ„</label>
      <input type="file" id="excelFile" accept=".xlsx, .xls" title="ÙØªØ­ Ù…Ù„Ù" />
      <button type="button" id="uploadBtn">Ø±ÙØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Firebase</button>
      <div id="rowCountLabel" class="row-count-label"></div>
      <button type="button" id="checkDuplicatesBtn" class="btn-warning">
        Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±
      </button>
      <button type="button" id="clearColorsBtn" class="btn-grey">
        ØªÙ†Ø¸ÙŠÙ Ø§Ù„ØªÙ„ÙˆÙŠÙ†
      </button>
      <button type="button" id="deleteAllBtn" class="deleteAllBtn">
        Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      </button>

      <!-- Ù‚Ø³Ù… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù„Ù Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ -->
      <div class="file-selection">
        <h4>ğŸ“ Ø±ÙØ¹ Ù…Ù„Ù Excel ÙŠØ¯ÙˆÙŠÙ‹Ø§ (Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ)</h4>
        <button type="button" id="browseFileBtn" class="btn-outline">
          Ø§Ø®ØªØ± Ù…Ù„Ù Excel
        </button>
        <div id="selectedFileInfo" class="file-info">Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù</div>
        <div id="uploadStatus" class="upload-status"></div>
      </div>

      <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ -->
      <div class="time-settings">
        <h4>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ</h4>

        <div class="timse-controls">
          <div class="time-group">
            <label>ÙˆÙ‚Øª Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙŠÙˆÙ…ÙŠ:</label>
            <input type="time" id="autoUploadTime" class="time-input" value="12:22" />
          </div>

          <div class="time-group">
            <label>ÙˆÙ‚Øª Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ø¨Ù„ Ø§Ù„Ø±ÙØ¹ (Ø«ÙˆØ§Ù†ÙŠ):</label>
            <input type="number" id="waitTime" class="time-input" value="3" min="1" max="300" />
            <small class="input-hint">Ø§Ù„ÙˆÙ‚Øª Ø¨ÙŠÙ† ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙˆØ±ÙØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</small>
          </div>
        </div>

        <div class="time-actions">
          <button type="button" id="startAutoUpload" class="btn-primary">
            Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
          </button>
          <button type="button" id="stopAutoUpload" class="btn-secondary">
            Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
          </button>
        </div>

        <div class="time-actions">
          <button type="button" id="testAutoUpload" class="btn-outline">
            Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¢Ù†
          </button>
          <button type="button" id="resetSettings" class="btn-outline">
            Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
          </button>
        </div>

        <div class="status-indicator">
          <div id="statusDot" class="status-dot"></div>
          <span id="statusText">ØºÙŠØ± Ù†Ø´Ø·</span>
          <span id="nextRunInfo" class="next-run"></span>
        </div>

        <div class="log-container" id="uploadLog">
          <!-- Ø³Ø¬Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„Ø§Øª -->
        </div>

        <div class="important-note">
          <strong>Ù…Ù„Ø§Ø­Ø¸Ø© Ù…Ù‡Ù…Ø©:</strong> ÙŠØ¬Ø¨ Ø±ÙØ¹ Ù…Ù„Ù Excel ÙŠØ¯ÙˆÙŠÙ‹Ø§ Ø£ÙˆÙ„Ø§Ù‹ØŒ Ø«Ù… ÙŠØªÙ…
          Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ. Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ³Ù…Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù„ÙØ§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
          Ù…Ù† Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù….
        </div>
      </div>
    </div>

    <div class="table-wrapper">
      <div class="pagination-container">
        <button class="btn-pagination" id="prevBtn" onclick="changePage(-1)">Ø§Ù„Ø³Ø§Ø¨Ù‚</button>
        <span id="pageInfo">ØµÙØ­Ø© 1 Ù…Ù† 1</span>
        <button class="btn-pagination" id="nextBtn" onclick="changePage(1)">Ø§Ù„ØªØ§Ù„ÙŠ</button>
      </div>
      <div class="table-scroll">
        <table id="dataTable">
          <thead>
            <tr>
              <th>Sr</th>
              <th>Serial Num</th>
              <th>SIM S.Num</th>
              <th>Badge Number</th>
              <th>Manufacturer</th>
              <th>Model</th>
              <th>EEHC Unified code</th>
              <th>Facility Description</th>
              <th>Disco</th>
              <th>Disco Section</th>
              <th>Disco Branch</th>
              <th>Ù…Ù†Ø·Ù‚Ø©</th>
              <th>Losses Area</th>
              <th>Device function</th>
              <th>Distribution Facility (EEHC unified code)</th>
              <th>Installation Date</th>
              <th>ADDRESS4</th>
              <th>TYPE</th>
              <th>Latitude(y)</th>
              <th>Longitude(x)</th>
               <th>DivisionCode</th>
            </tr>
          </thead>
          <tbody>
            <!-- dynamically filled -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import {
      getDatabase,
      ref,
      set,
      get,
      remove,
      push,
    } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyABeLySOk_10XjaHSUjkfnR8f3HSTFkEYU",
      authDomain: "ndedc-smartmeter.firebaseapp.com",
      projectId: "ndedc-smartmeter",
      storageBucket: "ndedc-smartmeter.appspot.com",
      messagingSenderId: "557422247352",
      appId: "1:557422247352:web:824d4f96affd7bbb0fa34d",
      measurementId: "G-3DCP87C92Y",
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    console.log("Firebase initialized successfully!");

    // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
    let autoUploadInterval = null;
    let isAutoUploadRunning = false;
    let storedFileData = null;
    let storedFileName = "";
    let lastUploadTime = null;
    // Global State
    let allData = [];
    let filteredData = [];
    let currentPage = 1;
    const rowsPerPage = 16; // Increased for better usability

    const tbody = document.querySelector("#dataTable tbody");

    // ========== Ø¯ÙˆØ§Ù„ Ø§Ù„Ø³Ø¬Ù„Ø§Øª ==========
    function addLog(message, type = "info") {
      console.log(
        `[${type.toUpperCase()}] ${new Date().toLocaleTimeString("ar-EG")}: ${message}`,
      );
      const logContainer = document.getElementById("uploadLog");
      if (logContainer) {
        const now = new Date();
        const timeString = now.toLocaleTimeString("ar-EG");
        const logEntry = document.createElement("div");
        logEntry.className = `log-entry log-${type}`;
        logEntry.innerHTML = `<span class="log-time">[${timeString}]</span> ${message}`;
        logContainer.prepend(logEntry);

        const logs = logContainer.querySelectorAll(".log-entry");
        if (logs.length > 20) {
          logs[logs.length - 1].remove();
        }
      }

      // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ù‚Ø·Ø©
      updateStatusIndicator();
    }

    // ========== ØªØ­Ø¯ÙŠØ« Ù…Ø¤Ø´Ø± Ø§Ù„Ø­Ø§Ù„Ø© ==========
    function updateStatusIndicator() {
      const statusDot = document.getElementById("statusDot");
      const statusText = document.getElementById("statusText");

      if (isAutoUploadRunning) {
        statusDot.classList.add("active");
        statusText.textContent = "Ù†Ø´Ø·";
        statusText.style.color = "#2ecc71";
      } else {
        statusDot.classList.remove("active");
        statusText.textContent = "ØºÙŠØ± Ù†Ø´Ø·";
        statusText.style.color = "#95a5a6";
      }
    }

    // ========== Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ==========
    function saveAutoUploadSettings() {
      try {
        const settings = {
          isRunning: isAutoUploadRunning,
          fileName: storedFileName,
          lastUploadTime: lastUploadTime,
          uploadTime: document.getElementById("autoUploadTime").value,
          waitTime: document.getElementById("waitTime").value,
        };
        localStorage.setItem("autoUploadSettings", JSON.stringify(settings));
      } catch (e) {
        console.error("ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª:", e);
      }
    }

    function loadAutoUploadSettings() {
      try {
        const settings = JSON.parse(
          localStorage.getItem("autoUploadSettings") || "{}",
        );

        if (settings.fileName) {
          storedFileName = settings.fileName;
          const fileInfo = document.getElementById("selectedFileInfo");
          if (fileInfo) {
            fileInfo.innerHTML = `
                        <strong>Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø­ÙÙˆØ¸:</strong> ${storedFileName}<br>
                        <small>Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ</small>
                    `;
          }
          addLog(`ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø®Ø²Ù†: ${storedFileName}`, "success");
        }

        if (settings.isRunning) {
          isAutoUploadRunning = settings.isRunning;
          updateStatusIndicator();
          addLog("Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù†Ø´Ø· Ù…Ù† Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©", "info");
        }

        if (settings.uploadTime) {
          document.getElementById("autoUploadTime").value =
            settings.uploadTime;
        }

        if (settings.waitTime) {
          document.getElementById("waitTime").value = settings.waitTime;
        }

        lastUploadTime = settings.lastUploadTime || null;
      } catch (e) {
        console.error("ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª:", e);
      }
    }

    // ========== Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù ÙÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­Ù„ÙŠ ==========
    function saveFileToIndexedDB(file) {
      return new Promise((resolve, reject) => {
        try {
          const request = indexedDB.open("AutoUploadFilesDB", 1);

          request.onupgradeneeded = function (e) {
            const db = e.target.result;
            if (!db.objectStoreNames.contains("files")) {
              db.createObjectStore("files", { keyPath: "id" });
            }
          };

          request.onsuccess = function (e) {
            const db = e.target.result;
            const reader = new FileReader();

            reader.onload = function (event) {
              const fileData = event.target.result;
              const transaction = db.transaction(["files"], "readwrite");
              const store = transaction.objectStore("files");

              store.put({
                id: "autoUploadFile",
                name: file.name,
                data: Array.from(new Uint8Array(fileData)),
                size: file.size,
                type: file.type,
                lastModified: file.lastModified,
              });

              addLog(
                `ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©: ${file.name}`,
                "success",
              );
              resolve(file);
            };

            reader.onerror = () => reject(new Error("Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù"));
            reader.readAsArrayBuffer(file);
          };

          request.onerror = function (e) {
            reject(new Error("Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"));
          };
        } catch (error) {
          reject(error);
        }
      });
    }

    // ========== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ù…Ù† Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­Ù„ÙŠ ==========
    function loadFileFromIndexedDB() {
      return new Promise((resolve, reject) => {
        try {
          const request = indexedDB.open("AutoUploadFilesDB", 1);

          request.onsuccess = function (e) {
            const db = e.target.result;
            const transaction = db.transaction(["files"], "readonly");
            const store = transaction.objectStore("files");
            const getRequest = store.get("autoUploadFile");

            getRequest.onsuccess = function (event) {
              const fileData = event.target.result;
              if (fileData) {
                storedFileData = new Uint8Array(fileData.data).buffer;
                storedFileName = fileData.name;

                addLog(
                  `ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©: ${storedFileName}`,
                  "success",
                );
                resolve(fileData);
              } else {
                reject(new Error("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ù„Ù Ù…Ø®Ø²Ù†"));
              }
            };

            getRequest.onerror = function () {
              reject(new Error("Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"));
            };
          };

          request.onerror = function (e) {
            reject(new Error("Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"));
          };
        } catch (error) {
          reject(error);
        }
      });
    }

    // ========== Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ù…Ù† Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ==========
    async function autoUploadFromPC() {
      addLog("Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ù† Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±...", "info");

      try {
        // 1. Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø®Ø²Ù†
        try {
          await loadFileFromIndexedDB();
          addLog("ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø®Ø²Ù† Ø¨Ù†Ø¬Ø§Ø­", "success");
        } catch (error) {
          addLog(`âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ù„Ù Ù…Ø®Ø²Ù†: ${error.message}`, "error");
          return;
        }

        // 2. ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù ÙˆØ¹Ø±Ø¶Ù‡ ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„
        await loadExcelFromStoredData();

        // 3. Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯
        const waitTime =
          parseInt(document.getElementById("waitTime").value) || 3;
        addLog(
          `â³ Ø§Ù†ØªØ¸Ø§Ø± ${waitTime} Ø«ÙˆØ§Ù†ÙŠ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„...`,
          "info",
        );
        await new Promise((resolve) => setTimeout(resolve, waitTime * 1000));

        // 4. Ø±ÙØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Firebase
        const result = await uploadTableData();

        // 5. ØªØ­Ø¯ÙŠØ« ÙˆÙ‚Øª Ø¢Ø®Ø± ØªØ­Ù…ÙŠÙ„
        lastUploadTime = new Date().toISOString();
        saveAutoUploadSettings();

        addLog(
          `âœ… ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¨Ù†Ø¬Ø§Ø­: ${result.processed} ØµÙ Ø¬Ø¯ÙŠØ¯`,
          "success",
        );

        return result;
      } catch (error) {
        addLog(`âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ: ${error.message}`, "error");
        throw error;
      }
    }

    // ========== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© ==========
    async function loadExcelFromStoredData() {
      return new Promise((resolve, reject) => {
        try {
          if (!storedFileData) {
            reject(new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù„Ù Ù…Ø®Ø²Ù†Ø©"));
            return;
          }

          addLog("Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø®Ø²Ù†...", "info");

          const data = new Uint8Array(storedFileData);
          let workbook;

          try {
            workbook = XLSX.read(data, { type: "array" });
          } catch (e) {
            const binaryString = Array.from(data)
              .map((char) => String.fromCharCode(char))
              .join("");
            workbook = XLSX.read(binaryString, { type: "binary" });
          }

          let sheetName = workbook.SheetNames[0];
          sheetName = workbook.SheetNames[0];

          const worksheet = workbook.Sheets[sheetName];

          if (!worksheet) {
            reject(new Error("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙˆØ±Ù‚Ø© Ø¹Ù…Ù„ ÙÙŠ Ø§Ù„Ù…Ù„Ù!"));
            return;
          }

          const excelData = XLSX.utils.sheet_to_json(worksheet, {
            defval: "",
          });
          populateTable(excelData);

          addLog(`âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ ${excelData.length} ØµÙ Ù…Ù† Ø§Ù„Ù…Ù„Ù`, "success");
          resolve();
        } catch (error) {
          reject(new Error(`Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„Ù: ${error.message}`));
        }
      });
    }

    // ========== Ø­ÙØ¸ Ù…Ù„Ù Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ==========
    async function storeFileForAutoUpload(file) {
      return new Promise((resolve, reject) => {
        try {
          addLog(`Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù: ${file.name}`, "info");

          // 1. Ø­ÙØ¸ ÙÙŠ Ù…ØªØºÙŠØ± Ø¬Ø§ÙØ§ Ø³ÙƒØ±ÙŠØ¨Øª
          const reader = new FileReader();
          reader.onload = (evt) => {
            try {
              storedFileData = evt.target.result;
              storedFileName = file.name;

              // 2. Ø­ÙØ¸ ÙÙŠ IndexedDB Ù„Ù„Ù…Ø³ØªÙ‚Ø¨Ù„
              saveFileToIndexedDB(file)
                .then(() => {
                  // 3. ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                  const fileInfo =
                    document.getElementById("selectedFileInfo");
                  if (fileInfo) {
                    fileInfo.innerHTML = `
                                    <strong>Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø­ÙÙˆØ¸:</strong> ${storedFileName}<br>
                                    <small>Ø§Ù„Ø­Ø¬Ù…: ${(file.size / 1024).toFixed(2)} KB</small><br>
                                    <small>âœ… Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ</small>
                                `;
                  }

                  // 4. Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
                  saveAutoUploadSettings();

                  addLog(
                    `âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ: ${storedFileName}`,
                    "success",
                  );
                  resolve(file);
                })
                .catch((err) => {
                  addLog(
                    `âŒ Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ${err.message}`,
                    "error",
                  );
                  reject(err);
                });
            } catch (error) {
              reject(error);
            }
          };

          reader.onerror = () => reject(new Error("Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù"));
          reader.readAsArrayBuffer(file);
        } catch (error) {
          reject(error);
        }
      });
    }

    function populateTable(excelData) {
      const normalizeHeader = (value) =>
        String(value || "")
          .toLowerCase()
          .replace(/[^a-z0-9\u0600-\u06ff]/g, "");

      allData = excelData.map((item, index) => {
        const normalizedItem = {};
        Object.keys(item || {}).forEach((rawKey) => {
          normalizedItem[normalizeHeader(rawKey)] = item[rawKey];
        });

        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙŠÙ…
        const getValue = (keys) => {
          for (const key of keys) {
            const directValue = item[key];
            if (
              directValue !== undefined &&
              directValue !== null &&
              directValue !== ""
            ) {
              return directValue;
            }

            const normalizedValue = normalizedItem[normalizeHeader(key)];
            if (
              normalizedValue !== undefined &&
              normalizedValue !== null &&
              normalizedValue !== ""
            ) {
              return normalizedValue;
            }
          }
          return "";
        };

        return {
          sr: index + 1,
          serial: getValue([
            "Serial Num",
            "Serial",
            "Serial Number",
            "SerialNum",
          ]),
          sim: getValue(["SIM S.Num", "SIM", "SIM_S_Num"]),
          badge: getValue(["Badge Number", "Badge", "BadgeNumber"]),
          manuf: getValue(["Manufacturer"]),
          model: getValue(["Model"]),
          code1: getValue(["EEHC Unified code", "EEHCUnifiedCode"]),
          facDesc: getValue([
            "Facililty Description",
            "Facility Description",
            "FacilityDescription",
          ]),
          disco: getValue(["Disco ", "Disco"]),
          discoSec: getValue(["Disco Section", "Section", "DiscoSection"]),
          discoBranch: getValue(["Disco Branch", "Branch", "DiscoBranch"]),
          area: getValue(["Ù…Ù†Ø·Ù‚Ø©", "Area"]),
          lossArea: getValue(["Losses Area", "Loss Area", "LossesArea"]),
          devFunc: getValue(["Device function", "Function", "DeviceFunction"]),
          distFac: getValue([
            "Distribution Facility (EEHC unified code)",
            "Distribution Facility",
            "DistributionFacility",
          ]),
          installDate: getValue([
            "Installation Date",
            "Install Date",
            "Date_Installation",
          ]),
          addr4: getValue(["ADDRESS4", "Address", "Address4"]),
          type: getValue(["TYPE", "Type"]),
          lat: getValue(["Latitude(y)", "Latitude", "LatitudeY"]),
          lon: getValue(["Longitude(x)", "Longitude", "LongitudeX"]),
          dive: getValue(["DivisionCode"]),
        };
      });

      currentPage = 1;
      updateTable(allData);
    }

    function excelDateToJSDate(value) {
      if (value === undefined || value === null || value === "") return "";

      const toDDMMYYYY = (dateObj) => {
        if (!(dateObj instanceof Date) || isNaN(dateObj.getTime())) return "";
        const dd = String(dateObj.getDate()).padStart(2, "0");
        const mm = String(dateObj.getMonth() + 1).padStart(2, "0");
        const yyyy = dateObj.getFullYear();
        return `${dd}/${mm}/${yyyy}`;
      };

      if (value instanceof Date) {
        return toDDMMYYYY(value);
      }

      const raw = String(value).trim();
      if (!raw) return "";

      // Already dd/mm/yyyy or d/m/yyyy
      let match = raw.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
      if (match) {
        const dd = String(parseInt(match[1], 10)).padStart(2, "0");
        const mm = String(parseInt(match[2], 10)).padStart(2, "0");
        const yyyy = match[3];
        return `${dd}/${mm}/${yyyy}`;
      }

      // yyyy-mm-dd or yyyy/mm/dd
      match = raw.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/);
      if (match) {
        const yyyy = match[1];
        const mm = String(parseInt(match[2], 10)).padStart(2, "0");
        const dd = String(parseInt(match[3], 10)).padStart(2, "0");
        return `${dd}/${mm}/${yyyy}`;
      }

      // Numeric Excel date serial
      const num = Number(raw);
      if (!isNaN(num) && Number.isFinite(num)) {
        try {
          const utc_days = Math.floor(num - 25569);
          const utc_value = utc_days * 86400;
          const dateInfo = new Date(utc_value * 1000);
          const formatted = toDDMMYYYY(dateInfo);
          if (formatted) return formatted;
        } catch (e) {
          // Fall through to generic parse below
        }
      }

      // Final fallback for parseable date strings
      const parsed = new Date(raw);
      const parsedFormatted = toDDMMYYYY(parsed);
      return parsedFormatted || raw;
    }

    // ========== Ø±ÙØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Firebase Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø± ==========
    async function uploadTableData() {
      const overlay = document.getElementById("pageOverlay");
      if (overlay) overlay.style.display = "flex";

      // Use allData instead of tbody rows to ensure all data is uploaded
      if (!allData || !allData.length) {
        if (overlay) overlay.style.display = "none";
        throw new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø¥Ø¶Ø§ÙØªÙ‡Ø§.");
      }

      const dataToUpload = allData;
      let processed = 0;
      let errors = 0;
      let duplicates = 0;

      addLog(`Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ ${dataToUpload.length} ØµÙ Ø¥Ù„Ù‰ Firebase...`, "info");

      try {
        // 1. Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ØªØ³Ù„Ø³Ù„ÙŠØ© Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Firebase
        addLog("Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙƒØ±Ø±Ø©...", "info");
        const snapshot = await get(ref(db, "SMART"));
        const existingSerials = new Set();

        if (snapshot.exists()) {
          snapshot.forEach((childSnap) => {
            const data = childSnap.val();
            if (data.serial) {
              existingSerials.add(data.serial.toString().trim());
            }
          });
        }

        addLog(
          `ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${existingSerials.size} Ø±Ù‚Ù… ØªØ³Ù„Ø³Ù„ÙŠ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª`,
          "info",
        );

        // 2. Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±
        for (const item of dataToUpload) {
          // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù‚Ù… Ø§Ù„ØªØ³Ù„Ø³Ù„ÙŠ ÙˆØªÙ†Ø¸ÙŠÙÙ‡
          let serial = (item.serial || "").toString().trim();

          if (!serial) {
            errors++;
            continue;
          }

          // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±Ù‚Ù… Ø§Ù„ØªØ³Ù„Ø³Ù„ÙŠ Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ Ø¨Ø§Ù„ÙØ¹Ù„
          if (existingSerials.has(serial)) {
            duplicates++;
            continue; // ØªØ®Ø·ÙŠ Ù‡Ø°Ø§ Ø§Ù„ØµÙ
          }

          const payload = {
            serial,
            sim: (item.sim || "").toString().trim(),
            badge: (item.badge || "").toString().trim(),
            manuf: (item.manuf || "").toString().trim(),
            model: (item.model || "").toString().trim(),
            code1: (item.code1 || "").toString().trim(),
            facDesc: (item.facDesc || "").toString().trim(),
            disco: (item.disco || "").toString().trim(),
            discoSec: (item.discoSec || "").toString().trim(),
            discoBranch: (item.discoBranch || "").toString().trim(),
            area: (item.area || "").toString().trim(),
            lossArea: (item.lossArea || "").toString().trim(),
            devFunc: (item.devFunc || "").toString().trim(),
            distFac: (item.distFac || "").toString().trim(),
            installDate: excelDateToJSDate(item.installDate),
            addr4: (item.addr4 || "").toString().trim(),
            type: (item.type || "").toString().trim(),
            lat: (item.lat || "").toString().trim(),
            lon: (item.lon || "").toString().trim(),
            dive: (item.dive || "").toString().trim(),
            createdAt: new Date().toISOString(), // Ø¥Ø¶Ø§ÙØ© ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡
          };

          try {
            await set(ref(db, `SMART/${serial}`), payload);

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø±Ù‚Ù… Ø§Ù„ØªØ³Ù„Ø³Ù„ÙŠ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø± ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø¬Ù„Ø³Ø©
            existingSerials.add(serial);

            processed++;

            // Log occasionally to avoid freezing UI
            if (processed % 50 === 0) {
              addLog(`âœ… ØªÙ… Ø±ÙØ¹ ${processed} ØµÙ...`, "success");
            }
          } catch (e) {
            errors++;
            addLog(
              `âŒ Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„Ø±Ù‚Ù… Ø§Ù„ØªØ³Ù„Ø³Ù„ÙŠ ${serial}: ${e.message}`,
              "error",
            );
          }
        }
      } catch (error) {
        addLog(`âŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©: ${error.message}`, "error");
        if (overlay) overlay.style.display = "none";
        throw error;
      }

      if (overlay) overlay.style.display = "none";
      updateRowCount();

      // Ø¹Ø±Ø¶ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†ØªØ§Ø¦Ø¬
      let resultMessage = `âœ… ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: `;
      const parts = [];

      if (processed > 0) parts.push(`ØªÙ… Ø±ÙØ¹ ${processed} ØµÙ Ø¬Ø¯ÙŠØ¯`);
      if (duplicates > 0) parts.push(`ØªÙ… ØªØ®Ø·ÙŠ ${duplicates} ØµÙ Ù…ÙƒØ±Ø±`);
      if (errors > 0) parts.push(`Ø­Ø¯Ø«Øª ${errors} Ø£Ø®Ø·Ø§Ø¡`);

      resultMessage += parts.join("ØŒ ") + ".";

      addLog(resultMessage, processed > 0 ? "success" : "info");

      // Ø¹Ø±Ø¶ ØªÙ†Ø¨ÙŠÙ‡ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
      if (duplicates > 0) {
        alert(
          `ØªÙ… Ø±ÙØ¹ ${processed} ØµÙ Ø¬Ø¯ÙŠØ¯ Ø¨Ù†Ø¬Ø§Ø­.\nØªÙ… ØªØ®Ø·ÙŠ ${duplicates} ØµÙ Ù…ÙƒØ±Ø± (Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª).`,
        );
      } else if (processed > 0) {
        alert(`ØªÙ… Ø±ÙØ¹ ${processed} ØµÙ Ø¬Ø¯ÙŠØ¯ Ø¨Ù†Ø¬Ø§Ø­.`);
      } else if (duplicates === dataToUpload.length) {
        alert(
          "Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ù„Ù… ÙŠØªÙ… Ø±ÙØ¹ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©.",
        );
      }

      return { processed, duplicates, errors };
    }

    // ========== Ø¯Ø§Ù„Ø© Ù„ØªÙ†Ø¸ÙŠÙ Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„ ==========
    function clearTableColors() {
      if (!tbody) return;

      const rows = Array.from(tbody.rows);
      rows.forEach((row) => {
        row.classList.remove(
          "row-success",
          "row-duplicate",
          "row-error",
          "row-warning",
        );
        row.title = "";
        row.style.backgroundColor = "";
      });

      addLog("ØªÙ… ØªÙ†Ø¸ÙŠÙ ØªÙ„ÙˆÙŠÙ† Ø§Ù„Ø¬Ø¯ÙˆÙ„", "info");
    }

    // ========== Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø± ÙÙ‚Ø· ==========
    async function checkDuplicatesOnly() {
      if (!tbody || !tbody.rows.length) {
        alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡Ø§!");
        return;
      }

      const overlay = document.getElementById("pageOverlay");
      if (overlay) overlay.style.display = "flex";

      try {
        // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ù…Ù† Firebase
        const snapshot = await get(ref(db, "SMART"));
        const existingSerials = new Set();

        if (snapshot.exists()) {
          snapshot.forEach((childSnap) => {
            const data = childSnap.val();
            if (data.serial) {
              existingSerials.add(data.serial.toString().trim());
            }
          });
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙƒØ±Ø§Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„
        const rows = Array.from(tbody.rows);
        let duplicatesCount = 0;

        rows.forEach((row) => {
          const cells = row.cells;
          const serial = (cells[1]?.textContent || "").trim();

          if (serial && existingSerials.has(serial)) {
            row.classList.add("row-duplicate");
            row.title = `Ø§Ù„Ø±Ù‚Ù… Ø§Ù„ØªØ³Ù„Ø³Ù„ÙŠ ${serial} Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª`;
            duplicatesCount++;
          } else {
            row.classList.remove("row-duplicate");
            row.title = "";
          }
        });

        if (duplicatesCount > 0) {
          alert(
            `ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${duplicatesCount} ØµÙ Ù…ÙƒØ±Ø± ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.\nØªÙ… ØªÙ…ÙŠÙŠØ²Ù‡Ø§ Ø¨Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£ØµÙØ±.`,
          );
        } else {
          alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…ÙƒØ±Ø±Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.");
        }
      } catch (error) {
        alert(`Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±: ${error.message}`);
      }

      if (overlay) overlay.style.display = "none";
    }

    // ========== ØªØ­Ø¯ÙŠØ« ÙˆØ¸ÙŠÙØ© Ø§Ù„Ø­Ø°Ù Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø£Ù„ÙˆØ§Ù† ==========
    document
      .getElementById("restorbtn")
      ?.addEventListener("click", async () => {
        const overlay = document.getElementById("pageOverlay");
        if (overlay) overlay.style.display = "flex";

        // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        clearTableColors();

        try {
          const snapshot = await get(ref(db, "SMART"));
          if (!snapshot.exists()) {
            alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!");
            allData = [];
            updateTable([]);
            return;
          }

          const restoredData = [];
          let index = 1;
          snapshot.forEach((childSnap) => {
            const data = childSnap.val();
            restoredData.push({
              sr: index++,
              serial: data.serial || "",
              sim: data.sim || "",
              badge: data.badge || "",
              manuf: data.manuf || "",
              model: data.model || "",
              code1: data.code1 || "",
              facDesc: data.facDesc || "",
              disco: data.disco || "",
              discoSec: data.discoSec || "",
              discoBranch: data.discoBranch || "",
              area: data.area || "",
              lossArea: data.lossArea || "",
              devFunc: data.devFunc || "",
              distFac: data.distFac || "",
              installDate: data.installDate || "",
              addr4: data.addr4 || "",
              type: data.type || "",
              lat: data.lat || "",
              lon: data.lon || "",
              dive: data.dive || "",
            });
          });

          allData = restoredData;
          currentPage = 1;
          updateTable(allData);
          addLog(
            `ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ${allData.length} ØµÙ Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª`,
            "success",
          );
        } catch (error) {
          addLog(`âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ${error.message}`, "error");
        } finally {
          if (overlay) overlay.style.display = "none";
        }
      });

    // ========== Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ ==========
    function startAutoUploadAtTime(timeString) {
      if (!storedFileData) {
        alert("ÙŠØ±Ø¬Ù‰ Ø­ÙØ¸ Ù…Ù„Ù Excel Ø£ÙˆÙ„Ø§Ù‹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø²Ø± 'Ø§Ø®ØªØ± Ù…Ù„Ù Excel'!");
        return;
      }

      if (isAutoUploadRunning) {
        stopAutoUpload();
      }

      isAutoUploadRunning = true;
      saveAutoUploadSettings();
      updateStatusIndicator();

      // Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
      const now = new Date();
      const [hours, minutes] = timeString.split(":").map(Number);
      const targetTime = new Date();
      targetTime.setHours(hours, minutes, 0, 0);

      // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙˆÙ‚Øª Ù‚Ø¯ Ù…Ø¶Ù‰ØŒ Ø£Ø¶Ù ÙŠÙˆÙ…
      if (targetTime < now) {
        targetTime.setDate(targetTime.getDate() + 1);
      }

      const timeUntilUpload = targetTime - now;

      addLog(
        `âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ - Ø³ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø³Ø§Ø¹Ø© ${timeString}`,
        "success",
      );

      // Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
      if (autoUploadInterval) {
        clearTimeout(autoUploadInterval);
      }

      autoUploadInterval = setTimeout(async () => {
        if (isAutoUploadRunning) {
          addLog("ğŸ”„ ØªÙ…ÙˆØ¹Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ - Ø¨Ø¯Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©...", "info");
          await autoUploadFromPC();

          // Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„ØªØ§Ù„ÙŠ ÙŠÙˆÙ…ÙŠØ§Ù‹
          scheduleDailyAutoUpload(timeString);
        }
      }, timeUntilUpload);

      const nextTime = new Date(Date.now() + timeUntilUpload);
      const nextRunInfo = document.getElementById("nextRunInfo");
      if (nextRunInfo) {
        nextRunInfo.textContent = `Ø§Ù„ØªØ§Ù„ÙŠ: ${nextTime.toLocaleTimeString("ar-EG")}`;
      }
    }

    function scheduleDailyAutoUpload(timeString) {
      // Ø¬Ø¯ÙˆÙ„Ø© ÙŠÙˆÙ…ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ 24 Ø³Ø§Ø¹Ø©
      if (autoUploadInterval) {
        clearTimeout(autoUploadInterval);
      }

      autoUploadInterval = setTimeout(
        async () => {
          if (isAutoUploadRunning) {
            addLog("ğŸ”„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø§Ù„ÙŠÙˆÙ…ÙŠ - Ø¨Ø¯Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©...", "info");
            await autoUploadFromPC();

            // Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
            scheduleDailyAutoUpload(timeString);
          }
        },
        24 * 60 * 60 * 1000,
      ); // 24 Ø³Ø§Ø¹Ø©
    }

    function stopAutoUpload() {
      if (!isAutoUploadRunning) return;

      if (autoUploadInterval) {
        clearTimeout(autoUploadInterval);
        autoUploadInterval = null;
      }

      isAutoUploadRunning = false;
      saveAutoUploadSettings();
      updateStatusIndicator();

      const nextRunInfo = document.getElementById("nextRunInfo");
      if (nextRunInfo) {
        nextRunInfo.textContent = "";
      }

      addLog("â¹ï¸ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ", "info");
    }

    function updateRowCount() {
      const label = document.getElementById("rowCountLabel");
      if (label) {
        const totalLoaded = filteredData.length || allData.length || 0;
        const visibleRows = tbody ? tbody.rows.length : 0;
        label.textContent = `Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØµÙÙˆÙ Ø§Ù„Ù…Ø­Ù…Ù„Ø©: ${totalLoaded} (Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶ Ø§Ù„Ø¢Ù†: ${visibleRows})`;
      }
    }

    // ========== Event Listeners ==========
    // Ø²Ø± Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù Ù„Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
    document
      .getElementById("browseFileBtn")
      ?.addEventListener("click", () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".xlsx, .xls";

        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              await storeFileForAutoUpload(file);
            } catch (error) {
              addLog(`âŒ Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù: ${error.message}`, "error");
            }
          }
        };

        input.click();
      });

    // Ø±ÙØ¹ Ù…Ù„Ù ÙŠØ¯ÙˆÙŠØ§Ù‹ ÙˆØ¹Ø±Ø¶Ù‡
    document
      .getElementById("excelFile")
      ?.addEventListener("change", function (e) {
        const file = e.target.files[0];
        if (!file) return;

        // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        clearTableColors();

        addLog(`Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù: ${file.name}`, "info");

        const reader = new FileReader();
        reader.onload = function (evt) {
          try {
            const data = new Uint8Array(evt.target.result);
            const workbook = XLSX.read(data, { type: "array" });

            let sheetName = workbook.SheetNames[0];
            sheetName = workbook.SheetNames[0];

            const worksheet = workbook.Sheets[sheetName];
            const excelData = XLSX.utils.sheet_to_json(worksheet, {
              defval: "",
            });

            populateTable(excelData);
            addLog(`âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ ${excelData.length} ØµÙ Ø¨Ù†Ø¬Ø§Ø­`, "success");
          } catch (error) {
            addLog(`âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù: ${error.message}`, "error");
          }
        };

        reader.readAsArrayBuffer(file);
      });

    // Ø±ÙØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Firebase ÙŠØ¯ÙˆÙŠØ§Ù‹
    document
      .getElementById("uploadBtn")
      ?.addEventListener("click", async () => {
        addLog("Ø¨Ø¯Ø¡ Ø±ÙØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙŠØ¯ÙˆÙŠØ§Ù‹ Ø¥Ù„Ù‰ Firebase...", "info");
        try {
          const result = await uploadTableData();
          addLog(
            `âœ… ØªÙ… Ø±ÙØ¹ ${result.processed} ØµÙ Ø¬Ø¯ÙŠØ¯ØŒ ØªØ®Ø·ÙŠ ${result.duplicates} Ù…ÙƒØ±Ø±ØŒ ${result.errors} Ø£Ø®Ø·Ø§Ø¡`,
            "success",
          );
        } catch (error) {
          addLog(`âŒ Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ${error.message}`, "error");
        }
      });

    // Ø²Ø± Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙƒØ±Ø§Ø±
    document
      .getElementById("checkDuplicatesBtn")
      ?.addEventListener("click", async () => {
        await checkDuplicatesOnly();
      });

    // Ø²Ø± ØªÙ†Ø¸ÙŠÙ Ø§Ù„ØªÙ„ÙˆÙŠÙ†
    document
      .getElementById("clearColorsBtn")
      ?.addEventListener("click", () => {
        clearTableColors();
      });

    // Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù†Ø¯ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯
    document
      .getElementById("startAutoUpload")
      ?.addEventListener("click", () => {
        const timeInput = document.getElementById("autoUploadTime");
        if (timeInput) {
          startAutoUploadAtTime(timeInput.value);
        } else {
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø­Ù‚Ù„ ÙˆÙ‚ØªØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ø§Ù„ÙŠ + 3 Ø«ÙˆØ§Ù†ÙŠ
          const now = new Date();
          const timeString = `${now.getHours().toString().padStart(2, "0")}:${now.getMinutes().toString().padStart(2, "0")}`;
          startAutoUploadAtTime(timeString);
        }
      });

    // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
    document
      .getElementById("stopAutoUpload")
      ?.addEventListener("click", stopAutoUpload);

    // Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙˆØ±ÙŠ
    document
      .getElementById("testAutoUpload")
      ?.addEventListener("click", async () => {
        addLog("ğŸ§ª Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙˆØ±ÙŠ...", "info");
        await autoUploadFromPC();
      });

    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    document
      .getElementById("resetSettings")
      ?.addEventListener("click", () => {
        if (confirm("Ù‡Ù„ ØªØ±ÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§ØªØŸ")) {
          localStorage.removeItem("autoUploadSettings");
          storedFileData = null;
          storedFileName = "";
          isAutoUploadRunning = false;
          lastUploadTime = null;

          document.getElementById("autoUploadTime").value = "12:22";
          document.getElementById("waitTime").value = "3";
          document.getElementById("selectedFileInfo").innerHTML =
            "Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù";

          if (autoUploadInterval) {
            clearTimeout(autoUploadInterval);
            autoUploadInterval = null;
          }

          updateStatusIndicator();
          addLog("ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª", "info");
        }
      });

    // Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    document
      .getElementById("deleteAllBtn")
      ?.addEventListener("click", async () => {
        const password = prompt("Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù„Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:");
        if (password !== "123") return alert("ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©!");
        if (!confirm("Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø£Ù†Ùƒ ØªØ±ÙŠØ¯ Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ")) return;

        try {
          await remove(ref(db, "SMART"));
          if (tbody) tbody.innerHTML = "";
          updateRowCount();
          addLog("ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", "info");
          alert("ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.");
        } catch (e) {
          addLog("âŒ ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", "error");
          alert("ÙØ´Ù„ Ø§Ù„Ø­Ø°Ù Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.");
        }
      });

    // ========== Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© ==========
    document.addEventListener("DOMContentLoaded", () => {
      // ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªØ§Ø±ÙŠØ®
      const today = new Date();
      const dateElement = document.getElementById("printDate");
      if (dateElement) {
        dateElement.textContent = today.toISOString().split("T")[0];
      }

      addLog("ğŸš€ ØªÙ… ØªØ­Ù…ÙŠÙ„ ØµÙØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø¨Ù†Ø¬Ø§Ø­", "success");

      // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø©
      loadAutoUploadSettings();
      updateStatusIndicator();
    });

    // Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙØ­Ø©
    window.addEventListener("beforeunload", () => {
      saveAutoUploadSettings();
    });

    // Update table with data
    function updateTable(data) {
      if (data) {
        filteredData = data;
        currentPage = 1;
      }

      const tableBody = document.querySelector("#dataTable tbody");
      tableBody.innerHTML = "";

      // 1. Calculate Pagination range
      const start = (currentPage - 1) * rowsPerPage;
      const end = start + rowsPerPage;
      const paginatedItems = filteredData.slice(start, end);

      // 2. Map data to the Table
      paginatedItems.forEach((item) => {
        const tr = document.createElement("tr");
        const fields = [
          "sr",
          "serial",
          "sim",
          "badge",
          "manuf",
          "model",
          "code1",
          "facDesc",
          "disco",
          "discoSec",
          "discoBranch",
          "area",
          "lossArea",
          "devFunc",
          "distFac",
          "installDate", // This will be formatted
          "addr4",
          "type",
          "lat",
          "lon",
          "dive",
        ];

        fields.forEach((field) => {
          const td = document.createElement("td");
          if (field === "installDate") {
            td.textContent = excelDateToJSDate(item[field]);
          } else {
            td.textContent = item[field] || "";
          }
          tr.appendChild(td);
        });
        tableBody.appendChild(tr);
      });

      // 3. Update UI Elements
      updatePagination();
      updateRowCount();
    }

    // --- Pagination & Navigation ---
    function updatePagination() {
      const totalPages = Math.max(
        1,
        Math.ceil(filteredData.length / rowsPerPage),
      );
      const pageInfo = document.getElementById("pageInfo");

      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");

      if (pageInfo)
        pageInfo.textContent = `Ø§Ù„ØµÙØ­Ø© ${currentPage} Ù…Ù† ${totalPages}`;
      if (prevBtn) prevBtn.disabled = currentPage === 1;
      if (nextBtn)
        nextBtn.disabled = currentPage === totalPages || totalPages === 0;
    }

    window.changePage = (dir) => {
      const totalPages = Math.ceil(filteredData.length / rowsPerPage);
      const target = currentPage + dir;
      if (target >= 1 && target <= totalPages) {
        currentPage = target;
        updateTable(); // Will use existing filteredData
      }
    };
  </script>
</body>

</html>
